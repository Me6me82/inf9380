
Some example to illustrate OpenMP


On Saga you can load the MPI module which also set up gcc/gfortran.
module load gompi/2019b


1)
False sharing example, learn this and avpind the pitfall later.

Initiate : gcc -c -DUNDERSCORE mysecond.c
This is a stopwatch, keep for future use. 

Compile for single thread (note the F90 instead of f90) :
gfortran-o  false-sharing.x -O0  false-sharing.F90 -DTHREADS=1 mysecond.o

Compile for many threads:
gfortran -o  false-sharing.x -O0 -fopenmp false-sharing.F90 -DTHREADS=<num-threads> mysecond.o 

Run with a single thread and note the time,


Mulitithread, set the number of threads you want to use, like for 4 threads :
then with more than one thread by setting OMP_NUM_THREADS
export OMP_NUM_THREADS=2

gfortran -o  false-sharing.x -O0 -fopenmp false-sharing.F90 -DTHREADS=4 mysecond.o
export OMP_NUM_THREADS=4


try 2, 4 and maybe some more, remember to recompile when changing the threads.
Note the wall time, whats happening ?

Explain what's happening ! Why are the run times as thay are. 

The source files with .F90 will be run through the fpp preprocessor (more common
for C programs cpp, where it's default to use cpp first), while .f90 will not.
Try renaming to .f90 and rerun the compilation. Then -DTHREADS=2 will not be
propagated as this a preprocessor step. 

Try asking the compile to optimize, it might help.
The compiler developers have worked for a considerable number of decades and
they have implemeted a lot of tricks. 




2)

Pi multi thread OpenMP example.

Set OMP_NUM_THREADS to 2 initially (export OMP_NUM_THREADS=2)


Try simple parallel loop:
gfortran -o pi.x -O3 -fopenmp -fopt-info computepi-1.f90
time -p ./pi.x 


Check difference from version 1. Check vectorization info.
gfortran -o pi.x -O3 -fopenmp -fopt-info computepi-2.f90
time -p ./pi.x
Try running it with export OMP_NUM_THREADS=1 
Note the result for pi i both cases. 

Set OMP_NUM_THREADS to 2 again and continue. 

Check for vectorization 
gfortran -o pi.x -O3 -fopenmp -fopt-info computepi-3.f90
time -p ./pi.x


Check the loop and vector syntax and note the different opt-info
gfortran -o pi.x -O3 -fopenmp -fopt-info computepi-4.f90
time -p ./pi.x


Try some more optimization, it might improve optimization, but at this level
it's compiler version dependent. 

gfortran -mavx2 -march=znver1 -Ofast -fopenmp -fopt-info -o pi.x  computepi-3.f90
time -p ./pi.x



Please not the execution times. Compile a little report on OpenMP parallel
execution combined with vectorization and keep for reference.

As an extra bonus you can recompile the different versions and look at the
machine instructions.

gfortran -c-S -O3 -fopenmp -fopt-info computepi-1.f90

Look at the file computepi-1.s, look for the div instruction.

Compare to the instructions generated by the computepi.[3,4].s :
gfortran -mavx2 -march=znver1 -Ofast -fopenmp -fopt-info -c -S computepi-3.f90
and
gfortran -mavx2 -march=znver1 -Ofast -fopenmp -fopt-info -c -S computepi-4.f90





If you have time you could make a make file to build the executables.

An example is shown here for the false-sharing example:


FOPT  = -O0 -fopenmp -mcmodel=medium
COPT  = -O2
FC	= gfortran
CC      = gcc 
THREADS = 4

all:            sharing.x Makefile 

mysecond.o:
	$(CC) $(COPT) -c -DUNDERSCORE mysecond.c

sharing.x: sharing.F90 mysecond.o Makefile
	$(FC) $(FOPT) -DTHREADS=$(THREADS) -o sharing.x sharing.F90 mysecond.o

run:	Makefile sharing.x 
	OMP_NUM_THREADS=$(THREADS) ./sharing.x 

clean:
	rm -f *.o sharing.x
